var documenterSearchIndex = {"docs":
[{"location":"apidocs/#API-Documentation","page":"API Documentation","title":"API Documentation","text":"","category":"section"},{"location":"apidocs/#SymEngine","page":"API Documentation","title":"SymEngine","text":"","category":"section"},{"location":"apidocs/#Index","page":"API Documentation","title":"Index","text":"","category":"section"},{"location":"apidocs/#SymEngine.AsciiArt","page":"API Documentation","title":"SymEngine.AsciiArt","text":"show symengine logo \n\n\n\n\n\n","category":"type"},{"location":"apidocs/#LinearAlgebra.lu-Tuple{SymEngine.CDenseMatrix}","page":"API Documentation","title":"LinearAlgebra.lu","text":"LU decomposition for CDenseMatrix, dense matrices of symbolic values\n\nAlso: lufact(a, val{:false}) for non-pivoting lu factorization\n\n\n\n\n\n","category":"method"},{"location":"apidocs/#SymEngine.N-Tuple{Integer}","page":"API Documentation","title":"SymEngine.N","text":"Convert a SymEngine numeric value into a Julian number\n\n\n\n\n\n","category":"method"},{"location":"apidocs/#SymEngine.coeff!-Tuple{Basic, Basic, Any, Any}","page":"API Documentation","title":"SymEngine.coeff!","text":"Return coefficient of x^n term, x a symbol\n\n\n\n\n\n","category":"method"},{"location":"apidocs/#SymEngine.free_symbols-Tuple{Basic}","page":"API Documentation","title":"SymEngine.free_symbols","text":"Return free symbols in an expression as a Set\n\n\n\n\n\n","category":"method"},{"location":"apidocs/#SymEngine.function_symbols-Tuple{Basic}","page":"API Documentation","title":"SymEngine.function_symbols","text":"Return function symbols in an expression as a Set\n\n\n\n\n\n","category":"method"},{"location":"apidocs/#SymEngine.get_args-Tuple{Basic}","page":"API Documentation","title":"SymEngine.get_args","text":"Return arguments of a function call as a vector of Basic objects\n\n\n\n\n\n","category":"method"},{"location":"apidocs/#SymEngine.get_libversion-Tuple{}","page":"API Documentation","title":"SymEngine.get_libversion","text":"Get libsymengine version\n\n\n\n\n\n","category":"method"},{"location":"apidocs/#SymEngine.get_name-Tuple{Basic}","page":"API Documentation","title":"SymEngine.get_name","text":"Return name of function symbol\n\n\n\n\n\n","category":"method"},{"location":"apidocs/#SymEngine.get_symbol-Tuple{Symbol}","page":"API Documentation","title":"SymEngine.get_symbol","text":"Helper function to lookup a symbol from libsymengine\n\n\n\n\n\n","category":"method"},{"location":"apidocs/#SymEngine.get_symengine_class-Tuple{Basic}","page":"API Documentation","title":"SymEngine.get_symengine_class","text":"Get SymEngine class of an object (e.g. 1=>:Integer, 1//2 =:Rational, sin(x) => :Sin, ...\n\n\n\n\n\n","category":"method"},{"location":"apidocs/#SymEngine.has_symbol-Tuple{Union{Basic, SymEngine.BasicType}, Union{Basic, SymEngine.BasicType}}","page":"API Documentation","title":"SymEngine.has_symbol","text":"Does expression contain the symbol\n\n\n\n\n\n","category":"method"},{"location":"apidocs/#SymEngine.have_component-Tuple{String}","page":"API Documentation","title":"SymEngine.have_component","text":"Check whether libsymengine was compiled with comp\n\n\n\n\n\n","category":"method"},{"location":"apidocs/#SymEngine.is_constant-Tuple{Basic}","page":"API Documentation","title":"SymEngine.is_constant","text":"Is expression constant\n\n\n\n\n\n","category":"method"},{"location":"apidocs/#SymEngine.is_symbol-Tuple{Union{Basic, SymEngine.BasicType}}","page":"API Documentation","title":"SymEngine.is_symbol","text":"Is expression a symbol\n\n\n\n\n\n","category":"method"},{"location":"apidocs/#SymEngine.lambdify","page":"API Documentation","title":"SymEngine.lambdify","text":"lambdify\n\nevaluates a symbolless expression or returns a function\n\n\n\n\n\n","category":"function"},{"location":"apidocs/#SymEngine.series","page":"API Documentation","title":"SymEngine.series","text":"Series expansion to order n about point x0\n\n\n\n\n\n","category":"function"},{"location":"apidocs/#SymEngine.subs-Union{Tuple{S}, Tuple{T}, Tuple{T, S, Any}} where {T<:Union{Basic, SymEngine.BasicType}, S<:Union{Basic, SymEngine.BasicType}}","page":"API Documentation","title":"SymEngine.subs","text":"subs\n\nSubstitute values into a symbolic expression.\n\nExamples\n\n@vars x y\nex = x^2 + y^2\nsubs(ex, x, 1) # 1 + y^2\nsubs(ex, (x, 1)) # 1 + y^2\nsubs(ex, (x, 1), (y,x)) # 1 + x^2, values are substituted left to right.\nsubs(ex, x=>1)  # alternate to subs(x, (x,1))\nsubs(ex, x=>1, y=>1) # ditto\n\n\n\n\n\n","category":"method"},{"location":"apidocs/#SymEngine.symbols-Tuple{Symbol}","page":"API Documentation","title":"SymEngine.symbols","text":"symbols(::Symbol) construct symbolic value\n\nExamples:\n\na = symbols(:a)\nx = symbols(\"x\")\nx,y = symbols(\"x y\")\nx,y,z = symbols(\"x,y,z\")\n\n\n\n\n\n","category":"method"},{"location":"apidocs/#SymEngine.@vars-Tuple","page":"API Documentation","title":"SymEngine.@vars","text":"@vars x y[1:5] z()\n\nMacro to define 1 or more variables or symbolic function\n\nExample\n\n@vars x y z\n@vars x[1:4]\n@vars u(), x\n\n\n\n\n\n","category":"macro"},{"location":"#SymEngine.jl-Documentation","page":"SymEngine.jl Documentation","title":"SymEngine.jl Documentation","text":"","category":"section"},{"location":"#About","page":"SymEngine.jl Documentation","title":"About","text":"This site contains the documentation and julia language bindings for the Symengine project.","category":"section"},{"location":"#Contents","page":"SymEngine.jl Documentation","title":"Contents","text":"","category":"section"},{"location":"#Installation","page":"SymEngine.jl Documentation","title":"Installation","text":"The package and dependencies can be obtained with standard Pkg calls.\n\njulia> Pkg.add(\"SymEngine\")","category":"section"},{"location":"basicUsage/#SymEngine.jl","page":"SymEngine.jl","title":"SymEngine.jl","text":"Julia wrappers for SymEngine, a fast symbolic manipulation library, written in C++.\n\nTo begin, we load the package, as any other:\n\nusing SymEngine","category":"section"},{"location":"basicUsage/#Working-with-scalar-variables","page":"SymEngine.jl","title":"Working with scalar variables","text":"","category":"section"},{"location":"basicUsage/#Defining-variables","page":"SymEngine.jl","title":"Defining variables","text":"One can define variables in a few ways. For interactive use, the @vars macro proves useful, creating the variable(s) in the local scope:\n\n@vars a b\n\nThe @vars macro can also be used to define collections of variables and symbolic functions.\n\nThe symbols constructor can be used as well, it takes a symbol or string and returns a symbolic variable with the expected name. A string with spaces is split to allow the specification of multiple variables.\n\na=symbols(:a); b=symbols(:b)\n\na,b = symbols(\"a b\")","category":"section"},{"location":"basicUsage/#Symbolic-expressions","page":"SymEngine.jl","title":"Symbolic expressions","text":"Symbolic expressions are built up from symbolic variables and numbers by calling many generic Julia functions.\n\nThis command defines an expression using the variables from earlier:\n\nex1 = a + 2(b+2)^2 + 2a + 3(a+1)\n\nOne can see that like values are grouped, but no expansion is done.","category":"section"},{"location":"basicUsage/#Mathematical-operations","page":"SymEngine.jl","title":"Mathematical operations","text":"The last example shows that the basic math operations have methods to work with symbolic expressions. The same is the case for many of Julia's generic mathematical operations.\n\n@vars x\nex = sin(x)^2 - x*tanh(exp(x))","category":"section"},{"location":"basicUsage/#The-Basic-type","page":"SymEngine.jl","title":"The Basic type","text":"The Basic type is a wrapper that holds a pointer to the underlying symengine object. In the examples above, both x, a variable, and ex, an expression, are of type Basic, though x has an internal type :Symbol and ex an internal type :Add. The Basic type constructor can also be used for the construction of numeric symbols, numeric expressions, and numeric numbers. For example,\n\nn = Basic(10)","category":"section"},{"location":"basicUsage/#Working-with-vector-and-matrix-variables","page":"SymEngine.jl","title":"Working with vector and matrix variables","text":"","category":"section"},{"location":"basicUsage/#The-@vars-macro","page":"SymEngine.jl","title":"The @vars macro","text":"The @vars macro allows indexing notation to define vectors or more general arrays:\n\n@vars x[1:2] A[1:2, 1:2]\n\nIndices may have offsets\n\n@vars y[-2:2]\n\nThe indices passed to @vars must be numeric literals.","category":"section"},{"location":"basicUsage/#Using-symbols","page":"SymEngine.jl","title":"Using symbols","text":"A vector of variables can also be defined using list comprehension and string interpolation. This allows for runtime-determination of size:\n\nn = 4\n[symbols(\"α_$i\") for i in 1:n]\n\nOne can also use a matrix comprehension and string interpolation to create matrices:\n\nW = [symbols(\"W_$(i)_$(j)\") for i in 1:3, j in 1:4]","category":"section"},{"location":"basicUsage/#Matrix-vector-multiplication","page":"SymEngine.jl","title":"Matrix-vector multiplication","text":"The above create Julia vectors and  matrices with symbolic components. The usual generic matrix operations can be employed. For example:\n\n@vars x[1:2] A[1:3,1:2]\nA * x","category":"section"},{"location":"basicUsage/#The-CDenseMatrix-class","page":"SymEngine.jl","title":"The CDenseMatrix class","text":"The symengine library provides a method for LU decomposition. It can be called on a matrix of Basic values, which is converted to an internal CDenseMatrix type that can be passed to the underlying symengine function.\n\n@vars a x\nA = [x (1 + a*x); x (1+a^2*x)]\nusing LinearAlgebra\nlu(A)\n\nLinear symbolic equations can be solved using \\:\n\n@vars A[1:2, 1:2] x[1:2]\nA \\ x\n\nAgain, this dispatches to a symengine call.\n\nAn inverse can be found\n\n@vars x\nA = [1 x; 2 x^2]\ninv(A)\n\nas can determinants, transposes, and adjoints\n\ndet(A)\n\nA = [im x; 2im x^2]\ntranspose(A)","category":"section"},{"location":"basicUsage/#Symbolic-operations","page":"SymEngine.jl","title":"Symbolic operations","text":"","category":"section"},{"location":"basicUsage/#as_numer_denom,-coeff","page":"SymEngine.jl","title":"as_numer_denom, coeff","text":"The function as_numer_denom takes a fractional expression and returns the numerator and denominator:\n\n@vars x y\nex = (exp(x) - 1) / x\nSymEngine.as_numer_denom(ex)\n\nThe coeff function returns the coefficient of specific power of a symbolic variable:\n\n@vars a b c x\np = a + b*x + c*x^2\n[SymEngine.coeff(p, x, i) for i in 0:2]","category":"section"},{"location":"basicUsage/#expand","page":"SymEngine.jl","title":"expand","text":"The expand method is used to multiply out terms in a product:\n\nexpand(a + 2(b+2)^2 + 2a + 3(a+1))\n\nThe expanded expression collects like terms, so may lead to a simplification:\n\nexpand((x + 1)*(x - 2) - (x - 1)*x)\n\nThe expand function is much more performant than that in Symbolics – this function, returning 8436 summands, runs about five times faster:\n\nfunction expand_test(a,b,c)\n    x = expand(((a+b+c+1)^20));\n    y = expand(((a+b+c+1)^15));\n    z = expand(x*y)\nend","category":"section"},{"location":"basicUsage/#subs","page":"SymEngine.jl","title":"subs","text":"The subs methods allows for substitution of parts of the expression tree with other expressions:\n\nsubs(a^2 + (b-2)^2, b=>a)\n\nsubs(a^2 + (b-2)^2, b=>2)\n\nsubs(a^2 + (b-2)^2, a=>2)\n\nsubs(a^2 + (b-2)^2, a^2=>2)\n\nsubs(a^2 + (b-2)^2, a=>2, b=>3)\n\nThe k=>v pair notation is used to specify what is to be substituted (k) and with what (v). As seen, both can be expressions and not just variables.\n\nThe call method for symbolic expressions dispatches to subs and can be called with pairs, as above, or just values. When just values are passed, they are paired with the values returned by free_symbols:\n\n@vars x y z\nex = x * y^2 * z^3\nex(2,3,4) == ex(x=>2, y=>3, z=>4) == ex(Pair.(free_symbols(ex), (2,3,4))...)","category":"section"},{"location":"basicUsage/#diff","page":"SymEngine.jl","title":"diff","text":"The diff function performs symbolic differentiation.\n\ndiff(a + 2(b+2)^2 + 2a + 3(a+1), b)\n\nHigher-order derivatives can be specified with a number\n\n@vars x\nex = sin(sin(x))\ndiff(ex, x, 3)\n\nMixed derivatives can be found:\n\n@vars a b x y\nex = a*x*y^2 + b*x^2*y\ndiff(ex, x, x, y) # also diff(ex, x, 2, y 1) does 2 in x one in y\n\nSymbolic functions can be defined and differentiated\n\n@vars x f()\ndiff(f(x), x)\n\nThe derivative operation in SymEngine is more performant than that from Symbolics – this function, which returns 744 summands, for D=diff is orders of magnitude faster than for D=Symbolics.derivative:\n\nfunction diff_test(D, x)\n    expr = sin(sin(sin(sin(x))));\n    for i = 1:10\n        expr = D(expr, x)\n    end\n    expr\nend","category":"section"},{"location":"basicUsage/#Numeric-values","page":"SymEngine.jl","title":"Numeric values","text":"There are a number of built-in constants holding symbolic values including: PI, E, IM, oo, zoo, NAN.\n\nAs well, symbolic numbers may be produced through substitution or directly through the Basic constructor:\n\nx = Basic(1)\nx/2\n\nTo convert a symbolic value to a value in julia can be done through the N function, which attempts to identify a matching type:\n\nN(x), N(x/2), N(PI)\n\nThe float method will convert the symbolic value to a floating point number:\n\nfloat(x), float(x/2), float(PI)\n\nThe SymEngine.evalf function does this conversion within symengine, whereas float first attempts to identify an appropriate Julia type through a call to N before then calling float.\n\nTo create a Julia function from an expression it is possible to use something like x -> float(ex), but more idiomatically, lambdify would be used:\n\n@vars x\nex = x * tanh(exp(x))\nl = lambdify(ex)\ntypeof(ex(1)), typeof(l(1))\n\nThe recipe for Plots just wraps an expression with lambdify.\n\nOther generic methods in Julia work on symbolic numbers, but not expressions, including: real, imag, trunc, and round. For some numeric expressions, first calling N then calling one of these functions is needed.","category":"section"},{"location":"basicUsage/#Introspection","page":"SymEngine.jl","title":"Introspection","text":"There are various methods allowing the introspection of symbolic values\n\nSymEngine.is_constant(ex) checks if the expression contains any free symbol; return false if so.\nSymEngine.has_symbol(ex,x) checks if symbolic expression contains the specific symbol.\nfree_symbols(ex) returns all the symbols in an expression. The SymEngine.function_symbols returns symbolic functions, such as defined by @vars f().\nSymEngine.get_args(ex) returns the arguments of a given expression; returning an empty vector if the expression has no arguments.\nThere are several predicate functions for checking the storage type of a symbolic number: SymEngine.is_a_Number, SymEngine.is_a_Integer,  SymEngine.is_a_Rational, SymEngine.is_a_RealDouble, SymEngine.is_a_RealMPFR, SymEngine.is_a_Complex, SymEngine.is_a_ComplexDouble, SymEngine.is_a_ComplexMPC. Importantly, these do not apply to a constant symbolic expression. That is, a test like SymEngine.is_a_Number(1 + exp(Basic(1))) will be false.\nSeveral generic predicate functions, iszero, isone, isinteger, isreal, isfinite, isinf, and isnan.\n\nThese are imperfect; it may be better to use N to return a numeric value in Julia and call their counterpart. Even then, symbolic numeric expressions may be subject to floating point roundoff that masks the true mathematical nature.\n\nThere are also methods to inspect the type that symengine uses to store an expression.\n\nSymEngine.get_type returns an unsigned integer uniquely identifying the type\nSymEngine.get_symengine_class returns a symbol representing the top-most operation or storage type of the object in symengine.\nSymEngine.get_julia_class returns a symbol representing the Julia type of the top-most operation or storage type of the object in symengine.\n\nIf TermInterface is loaded (below), the operation method returns the outermost function for a given expression.","category":"section"},{"location":"basicUsage/#Basic-variables-are-mutable","page":"SymEngine.jl","title":"Basic variables are mutable","text":"The Basic type is a Julia type wrapping an underlying symengine object. When a Julia method is called on symbolic objects, the method almost always resolves to some call (via ccall) into the libsymengine C++ library. The design typically involves mutating a newly constructed Basic variable. Some allocations can be saved by calling the mutating version of the operations:\n\n@vars x\na = Basic()\nSymEngine.sin!(a, x)\na\n\nOther types that may be useful to minimize allocations are SymEngine.CSetBasic and SymEngine.CVecBasic.","category":"section"},{"location":"basicUsage/#Use-with-SymbolicUtils-and-TermInterface","page":"SymEngine.jl","title":"Use with SymbolicUtils and TermInterface","text":"There is an extension for TermInterface (and SymbolicUtils) which should allow the symbolic simplification routines from SymbolicUtils to be of use.\n\nusing SymbolicUtils;\n@vars x\nsimplify(sin(x)^2 + cos(x)^2)\n\nThe TermInterface package allows general symbolic expression manipulation. This example shows how some of the functionality of subs can be programmed using the package's interface.\n\nusing TermInterface\n\nfunction map_matched(x, is_match, f)\n    if SymEngine.is_symbol(x)\n        return is_match(x) ? f(x) : x\n    end\n\n    is_match(x) && return f(x)\n    iscall(x) || return x\n    children = map_matched.(arguments(x), is_match, f)\n    maketerm(Basic, operation(x), children, nothing)\nend\n\nreplace_exact(ex, p, q) = map_matched(ex, ==(p), _ -> q)\n\nfunction replace_head(ex, u, v)\n    !iscall(ex) && return ex\n    args′ = (replace_head(a, u, v) for a ∈ arguments(ex))\n    op = operation(ex)\n    λ = op == u ? v : op\n    ex = maketerm(Basic, λ, args′, nothing)\nend\n\n@vars x u\nreplace_exact(sin(x^2)*cos(x^2), x^2, u) # subs(ex, p => q)\n\nreplace_head(tan(sin(tan(x))), tan, cos)","category":"section"},{"location":"basicUsage/#SymEngine.jl-and-symengine","page":"SymEngine.jl","title":"SymEngine.jl and symengine","text":"This package only wraps those parts of symengine that are exposed through its C wrapper. The underlying C++ library has more functionality.","category":"section"},{"location":"basicUsage/#License","page":"SymEngine.jl","title":"License","text":"SymEngine.jl is licensed under the MIT open source license.","category":"section"}]
}
