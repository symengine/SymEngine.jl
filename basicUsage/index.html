<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>SymEngine.jl · Symengine Julia API Docs</title><meta name="title" content="SymEngine.jl · Symengine Julia API Docs"/><meta property="og:title" content="SymEngine.jl · Symengine Julia API Docs"/><meta property="twitter:title" content="SymEngine.jl · Symengine Julia API Docs"/><meta name="description" content="Documentation for Symengine Julia API Docs."/><meta property="og:description" content="Documentation for Symengine Julia API Docs."/><meta property="twitter:description" content="Documentation for Symengine Julia API Docs."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Symengine Julia API Docs</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">SymEngine.jl Documentation</a></li><li><a class="tocitem" href="../apidocs/">API Documentation</a></li><li class="is-active"><a class="tocitem" href>SymEngine.jl</a><ul class="internal"><li><a class="tocitem" href="#Working-with-scalar-variables"><span>Working with scalar variables</span></a></li><li><a class="tocitem" href="#Working-with-vector-and-matrix-variables"><span>Working with vector and matrix variables</span></a></li><li><a class="tocitem" href="#Symbolic-operations"><span>Symbolic operations</span></a></li><li><a class="tocitem" href="#Numeric-values"><span>Numeric values</span></a></li><li><a class="tocitem" href="#Introspection"><span>Introspection</span></a></li><li><a class="tocitem" href="#Basic-variables-are-mutable"><span>Basic variables are mutable</span></a></li><li><a class="tocitem" href="#Use-with-SymbolicUtils-and-TermInterface"><span>Use with <code>SymbolicUtils</code> and <code>TermInterface</code></span></a></li><li><a class="tocitem" href="#SymEngine.jl-and-symengine"><span><code>SymEngine.jl</code> and symengine</span></a></li><li><a class="tocitem" href="#License"><span>License</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>SymEngine.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>SymEngine.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/symengine/SymEngine.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/symengine/SymEngine.jl/blob/master/docs/src/basicUsage.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="SymEngine.jl"><a class="docs-heading-anchor" href="#SymEngine.jl">SymEngine.jl</a><a id="SymEngine.jl-1"></a><a class="docs-heading-anchor-permalink" href="#SymEngine.jl" title="Permalink"></a></h1><p>Julia wrappers for <a href="https://github.com/symengine/symengine">SymEngine</a>, a fast symbolic manipulation library, written in C++.</p><p>To begin, we load the package, as any other:</p><pre><code class="language-julia hljs">using SymEngine</code></pre><h2 id="Working-with-scalar-variables"><a class="docs-heading-anchor" href="#Working-with-scalar-variables">Working with scalar variables</a><a id="Working-with-scalar-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-scalar-variables" title="Permalink"></a></h2><h3 id="Defining-variables"><a class="docs-heading-anchor" href="#Defining-variables">Defining variables</a><a id="Defining-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-variables" title="Permalink"></a></h3><p>One can define variables in a few ways. For interactive use, the <code>@vars</code> macro proves useful, creating the variable(s) in the local scope:</p><pre><code class="language-julia hljs">@vars a b</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(a, b)</code></pre><p>The <code>@vars</code> macro can also be used to define collections of variables and symbolic functions.</p><p>The <code>symbols</code> constructor can be used as well, it takes a symbol or string and returns a symbolic variable with the expected name. A string with spaces is split to allow the specification of multiple variables.</p><pre><code class="language-julia hljs">a=symbols(:a); b=symbols(:b)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">b</code></pre><pre><code class="language-julia hljs">a,b = symbols(&quot;a b&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(a, b)</code></pre><h3 id="Symbolic-expressions"><a class="docs-heading-anchor" href="#Symbolic-expressions">Symbolic expressions</a><a id="Symbolic-expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-expressions" title="Permalink"></a></h3><p>Symbolic expressions are built up from symbolic variables and numbers by calling many generic Julia functions.</p><p>This command defines an expression using the variables from earlier:</p><pre><code class="language-julia hljs">ex1 = a + 2(b+2)^2 + 2a + 3(a+1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3*a + 3*(1 + a) + 2*(2 + b)^2</code></pre><p>One can see that like values are grouped, but no expansion is done.</p><h4 id="Mathematical-operations"><a class="docs-heading-anchor" href="#Mathematical-operations">Mathematical operations</a><a id="Mathematical-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-operations" title="Permalink"></a></h4><p>The last example shows that the basic math operations have methods to work with symbolic expressions. The same is the case for many of Julia&#39;s generic <a href="https://docs.julialang.org/en/v1/manual/mathematical-operations/">mathematical operations</a>.</p><pre><code class="language-julia hljs">@vars x
ex = sin(x)^2 - x*tanh(exp(x))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-x*tanh(exp(x)) + sin(x)^2</code></pre><h4 id="The-Basic-type"><a class="docs-heading-anchor" href="#The-Basic-type">The <code>Basic</code> type</a><a id="The-Basic-type-1"></a><a class="docs-heading-anchor-permalink" href="#The-Basic-type" title="Permalink"></a></h4><p>The <code>Basic</code> type is a wrapper that holds a pointer to the underlying symengine object. In the examples above, both <code>x</code>, a variable, and <code>ex</code>, an expression, are of type <code>Basic</code>, though <code>x</code> has an internal type <code>:Symbol</code> and <code>ex</code> an internal type <code>:Add</code>. The <code>Basic</code> type constructor can also be used for the construction of numeric symbols, numeric expressions, and numeric numbers. For example,</p><pre><code class="language-julia hljs">n = Basic(10)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10</code></pre><h2 id="Working-with-vector-and-matrix-variables"><a class="docs-heading-anchor" href="#Working-with-vector-and-matrix-variables">Working with vector and matrix variables</a><a id="Working-with-vector-and-matrix-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-vector-and-matrix-variables" title="Permalink"></a></h2><h3 id="The-@vars-macro"><a class="docs-heading-anchor" href="#The-@vars-macro">The <code>@vars</code> macro</a><a id="The-@vars-macro-1"></a><a class="docs-heading-anchor-permalink" href="#The-@vars-macro" title="Permalink"></a></h3><p>The <code>@vars</code> macro allows indexing notation to define vectors or more general arrays:</p><pre><code class="language-julia hljs">@vars x[1:2] A[1:2, 1:2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(Basic[x₁, x₂], Basic[A₁_₁ A₁_₂; A₂_₁ A₂_₂])</code></pre><p>Indices may have offsets</p><pre><code class="language-julia hljs">@vars y[-2:2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(Basic[y₋₂, y₋₁, y₀, y₁, y₂],)</code></pre><p>The indices passed to <code>@vars</code> must be numeric literals.</p><h3 id="Using-symbols"><a class="docs-heading-anchor" href="#Using-symbols">Using <code>symbols</code></a><a id="Using-symbols-1"></a><a class="docs-heading-anchor-permalink" href="#Using-symbols" title="Permalink"></a></h3><p>A vector of variables can also be defined using list comprehension and string interpolation. This allows for runtime-determination of size:</p><pre><code class="language-julia hljs">n = 4
[symbols(&quot;α_$i&quot;) for i in 1:n]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Basic}:
 α_1
 α_2
 α_3
 α_4</code></pre><p>One can also use a matrix comprehension and string interpolation to create matrices:</p><pre><code class="language-julia hljs">W = [symbols(&quot;W_$(i)_$(j)&quot;) for i in 1:3, j in 1:4]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×4 Matrix{Basic}:
 W_1_1  W_1_2  W_1_3  W_1_4
 W_2_1  W_2_2  W_2_3  W_2_4
 W_3_1  W_3_2  W_3_3  W_3_4</code></pre><h3 id="Matrix-vector-multiplication"><a class="docs-heading-anchor" href="#Matrix-vector-multiplication">Matrix-vector multiplication</a><a id="Matrix-vector-multiplication-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-vector-multiplication" title="Permalink"></a></h3><p>The above create Julia vectors and  matrices with symbolic components. The usual generic matrix operations can be employed. For example:</p><pre><code class="language-julia hljs">@vars x[1:2] A[1:3,1:2]
A * x</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Basic}:
 x₁*A₁_₁ + x₂*A₁_₂
 x₁*A₂_₁ + x₂*A₂_₂
 x₁*A₃_₁ + x₂*A₃_₂</code></pre><h3 id="The-CDenseMatrix-class"><a class="docs-heading-anchor" href="#The-CDenseMatrix-class">The <code>CDenseMatrix</code> class</a><a id="The-CDenseMatrix-class-1"></a><a class="docs-heading-anchor-permalink" href="#The-CDenseMatrix-class" title="Permalink"></a></h3><p>The <code>symengine</code> library provides a method for LU decomposition. It can be called on a matrix of <code>Basic</code> values, which is converted to an internal <code>CDenseMatrix</code> type that can be passed to the underlying symengine function.</p><pre><code class="language-julia hljs">@vars a x
A = [x (1 + a*x); x (1+a^2*x)]
using LinearAlgebra
lu(A)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LinearAlgebra.LU{Basic, Matrix{Basic}}
L factor:
2×2 Matrix{Basic}:
 1  0
 1  1
U factor:
2×2 Matrix{Basic}:
 x                1 + a*x
 0  1 + a^2*x - (1 + a*x)</code></pre><p>Linear symbolic equations can be solved using <code>\</code>:</p><pre><code class="language-julia hljs">@vars A[1:2, 1:2] x[1:2]
A \ x</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Basic}:
 (x₁ - (x₂ - x₁*A₂_₁/A₁_₁)*A₁_₂/(A₂_₂ - A₂_₁*A₁_₂/A₁_₁))/A₁_₁
                  (x₂ - x₁*A₂_₁/A₁_₁)/(A₂_₂ - A₂_₁*A₁_₂/A₁_₁)</code></pre><p>Again, this dispatches to a symengine call.</p><p>An inverse can be found</p><pre><code class="language-julia hljs">@vars x
A = [1 x; 2 x^2]
inv(A)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Basic}:
 1 + 2*x/(-2*x + x^2)    -x/(-2*x + x^2)
      -2/(-2*x + x^2)  (-2*x + x^2)^(-1)</code></pre><p>as can determinants, transposes, and adjoints</p><pre><code class="language-julia hljs">det(A)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-2*x + x^2</code></pre><pre><code class="language-julia hljs">A = [im x; 2im x^2]
transpose(A)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Basic}:
 im  2*im
  x   x^2</code></pre><h2 id="Symbolic-operations"><a class="docs-heading-anchor" href="#Symbolic-operations">Symbolic operations</a><a id="Symbolic-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-operations" title="Permalink"></a></h2><h3 id="as_numer_denom,-coeff"><a class="docs-heading-anchor" href="#as_numer_denom,-coeff"><code>as_numer_denom</code>, <code>coeff</code></a><a id="as_numer_denom,-coeff-1"></a><a class="docs-heading-anchor-permalink" href="#as_numer_denom,-coeff" title="Permalink"></a></h3><p>The function <code>as_numer_denom</code> takes a fractional expression and returns the numerator and denominator:</p><pre><code class="language-julia hljs">@vars x y
ex = (exp(x) - 1) / x
SymEngine.as_numer_denom(ex)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(-1 + exp(x), x)</code></pre><p>The <code>coeff</code> function returns the coefficient of specific power of a symbolic variable:</p><pre><code class="language-julia hljs">@vars a b c x
p = a + b*x + c*x^2
[SymEngine.coeff(p, x, i) for i in 0:2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Basic}:
 a
 b
 c</code></pre><h3 id="expand"><a class="docs-heading-anchor" href="#expand"><code>expand</code></a><a id="expand-1"></a><a class="docs-heading-anchor-permalink" href="#expand" title="Permalink"></a></h3><p>The <code>expand</code> method is used to multiply out terms in a product:</p><pre><code class="language-julia hljs">expand(a + 2(b+2)^2 + 2a + 3(a+1))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">11 + 6*a + 8*b + 2*b^2</code></pre><p>The <code>expand</code>ed expression collects like terms, so may lead to a simplification:</p><pre><code class="language-julia hljs">expand((x + 1)*(x - 2) - (x - 1)*x)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-2</code></pre><p>The <code>expand</code> function is much more performant than that in <code>Symbolics</code> – this function, returning 8436 summands, runs about five times faster:</p><pre><code class="language-julia hljs">function expand_test(a,b,c)
    x = expand(((a+b+c+1)^20));
    y = expand(((a+b+c+1)^15));
    z = expand(x*y)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">expand_test (generic function with 1 method)</code></pre><h3 id="subs"><a class="docs-heading-anchor" href="#subs"><code>subs</code></a><a id="subs-1"></a><a class="docs-heading-anchor-permalink" href="#subs" title="Permalink"></a></h3><p>The <code>subs</code> methods allows for substitution of parts of the expression tree with other expressions:</p><pre><code class="language-julia hljs">subs(a^2 + (b-2)^2, b=&gt;a)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">a^2 + (-2 + a)^2</code></pre><pre><code class="language-julia hljs">subs(a^2 + (b-2)^2, b=&gt;2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">a^2</code></pre><pre><code class="language-julia hljs">subs(a^2 + (b-2)^2, a=&gt;2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4 + (-2 + b)^2</code></pre><pre><code class="language-julia hljs">subs(a^2 + (b-2)^2, a^2=&gt;2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2 + (-2 + b)^2</code></pre><pre><code class="language-julia hljs">subs(a^2 + (b-2)^2, a=&gt;2, b=&gt;3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5</code></pre><p>The <code>k=&gt;v</code> pair notation is used to specify what is to be substituted (<code>k</code>) and with what (<code>v</code>). As seen, both can be expressions and not just variables.</p><p>The <code>call</code> method for symbolic expressions dispatches to <code>subs</code> and can be called with pairs, as above, or just values. When just values are passed, they are paired with the values returned by <code>free_symbols</code>:</p><pre><code class="language-julia hljs">@vars x y z
ex = x * y^2 * z^3
ex(2,3,4) == ex(x=&gt;2, y=&gt;3, z=&gt;4) == ex(Pair.(free_symbols(ex), (2,3,4))...)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><h3 id="diff"><a class="docs-heading-anchor" href="#diff"><code>diff</code></a><a id="diff-1"></a><a class="docs-heading-anchor-permalink" href="#diff" title="Permalink"></a></h3><p>The <code>diff</code> function performs symbolic differentiation.</p><pre><code class="language-julia hljs">diff(a + 2(b+2)^2 + 2a + 3(a+1), b)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4*(2 + b)</code></pre><p>Higher-order derivatives can be specified with a number</p><pre><code class="language-julia hljs">@vars x
ex = sin(sin(x))
diff(ex, x, 3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-cos(x)*cos(sin(x)) - cos(x)^3*cos(sin(x)) + 3*sin(x)*cos(x)*sin(sin(x))</code></pre><p>Mixed derivatives can be found:</p><pre><code class="language-julia hljs">@vars a b x y
ex = a*x*y^2 + b*x^2*y
diff(ex, x, x, y) # also diff(ex, x, 2, y 1) does 2 in x one in y</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2*b</code></pre><p>Symbolic functions can be defined and differentiated</p><pre><code class="language-julia hljs">@vars x f()
diff(f(x), x)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Derivative(f(x), x)</code></pre><p>The derivative operation in <code>SymEngine</code> is more performant than that from <code>Symbolics</code> – this function, which returns 744 summands, for <code>D=diff</code> is orders of magnitude faster than for <code>D=Symbolics.derivative</code>:</p><pre><code class="language-julia hljs">function diff_test(D, x)
    expr = sin(sin(sin(sin(x))));
    for i = 1:10
        expr = D(expr, x)
    end
    expr
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">diff_test (generic function with 1 method)</code></pre><h2 id="Numeric-values"><a class="docs-heading-anchor" href="#Numeric-values">Numeric values</a><a id="Numeric-values-1"></a><a class="docs-heading-anchor-permalink" href="#Numeric-values" title="Permalink"></a></h2><p>There are a number of built-in constants holding symbolic values including: <code>PI</code>, <code>E</code>, <code>IM</code>, <code>oo</code>, <code>zoo</code>, <code>NAN</code>.</p><p>As well, symbolic numbers may be produced through substitution or directly through the <code>Basic</code> constructor:</p><pre><code class="language-julia hljs">x = Basic(1)
x/2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1/2</code></pre><p>To convert a symbolic value to a value in <code>julia</code> can be done through the <code>N</code> function, which attempts to identify a matching type:</p><pre><code class="language-julia hljs">N(x), N(x/2), N(PI)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(1, 1//2, π)</code></pre><p>The <code>float</code> method will convert the symbolic value to a floating point number:</p><pre><code class="language-julia hljs">float(x), float(x/2), float(PI)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(1.0, 0.5, 3.141592653589793)</code></pre><p>The <code>SymEngine.evalf</code> function does this conversion within symengine, whereas <code>float</code> first attempts to identify an appropriate Julia type through a call to <code>N</code> before then calling <code>float</code>.</p><p>To create a Julia function from an expression it is possible to use something like <code>x -&gt; float(ex)</code>, but more idiomatically, <code>lambdify</code> would be used:</p><pre><code class="language-julia hljs">@vars x
ex = x * tanh(exp(x))
l = lambdify(ex)
typeof(ex(1)), typeof(l(1))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(Basic, Float64)</code></pre><p>The recipe for <code>Plots</code> just wraps an expression with <code>lambdify</code>.</p><p>Other generic methods in Julia work on symbolic numbers, but not expressions, including: <code>real</code>, <code>imag</code>, <code>trunc</code>, and <code>round</code>. For some numeric expressions, first calling <code>N</code> then calling one of these functions is needed.</p><h2 id="Introspection"><a class="docs-heading-anchor" href="#Introspection">Introspection</a><a id="Introspection-1"></a><a class="docs-heading-anchor-permalink" href="#Introspection" title="Permalink"></a></h2><p>There are various methods allowing the introspection of symbolic values</p><ul><li><p><code>SymEngine.is_constant(ex)</code> checks if the expression contains any free symbol; return <code>false</code> if so.</p></li><li><p><code>SymEngine.has_symbol(ex,x)</code> checks if symbolic expression contains the specific symbol.</p></li><li><p><code>free_symbols(ex)</code> returns all the symbols in an expression. The <code>SymEngine.function_symbols</code> returns symbolic functions, such as defined by <code>@vars f()</code>.</p></li><li><p><code>SymEngine.get_args(ex)</code> returns the arguments of a given expression; returning an empty vector if the expression has no arguments.</p></li><li><p>There are several predicate functions for checking the storage type of a symbolic number: <code>SymEngine.is_a_Number</code>, <code>SymEngine.is_a_Integer</code>,  <code>SymEngine.is_a_Rational</code>, <code>SymEngine.is_a_RealDouble</code>, <code>SymEngine.is_a_RealMPFR</code>, <code>SymEngine.is_a_Complex</code>, <code>SymEngine.is_a_ComplexDouble</code>, <code>SymEngine.is_a_ComplexMPC</code>. Importantly, these do not apply to a constant symbolic expression. That is, a test like <code>SymEngine.is_a_Number(1 + exp(Basic(1)))</code> will be <code>false</code>.</p></li><li><p>Several generic predicate functions, <code>iszero</code>, <code>isone</code>, <code>isinteger</code>, <code>isreal</code>, <code>isfinite</code>, <code>isinf</code>, and <code>isnan</code>.</p></li></ul><p>These are imperfect; it may be better to use <code>N</code> to return a numeric value in Julia and call their counterpart. Even then, symbolic numeric expressions may be subject to floating point roundoff that masks the true mathematical nature.</p><p>There are also methods to inspect the type that symengine uses to store an expression.</p><ul><li><p><code>SymEngine.get_type</code> returns an unsigned integer uniquely identifying the type</p></li><li><p><code>SymEngine.get_symengine_class</code> returns a symbol representing the top-most operation or storage type of the object in symengine.</p></li><li><p><code>SymEngine.get_julia_class</code> returns a symbol representing the Julia type of the top-most operation or storage type of the object in symengine.</p></li></ul><p>If <code>TermInterface</code> is loaded (below), the <code>operation</code> method returns the outermost function for a given expression.</p><h2 id="Basic-variables-are-mutable"><a class="docs-heading-anchor" href="#Basic-variables-are-mutable">Basic variables are mutable</a><a id="Basic-variables-are-mutable-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-variables-are-mutable" title="Permalink"></a></h2><p>The <code>Basic</code> type is a Julia type wrapping an underlying symengine object. When a Julia method is called on symbolic objects, the method almost always resolves to some call (via <code>ccall</code>) into the <code>libsymengine</code> C++ library. The design typically involves mutating a newly constructed <code>Basic</code> variable. Some allocations can be saved by calling the mutating version of the operations:</p><pre><code class="nohighlight hljs">@vars x
a = Basic()
SymEngine.sin!(a, x)
a</code></pre><p>Other types that may be useful to minimize allocations are <code>SymEngine.CSetBasic</code> and <code>SymEngine.CVecBasic</code>.</p><h2 id="Use-with-SymbolicUtils-and-TermInterface"><a class="docs-heading-anchor" href="#Use-with-SymbolicUtils-and-TermInterface">Use with <code>SymbolicUtils</code> and <code>TermInterface</code></a><a id="Use-with-SymbolicUtils-and-TermInterface-1"></a><a class="docs-heading-anchor-permalink" href="#Use-with-SymbolicUtils-and-TermInterface" title="Permalink"></a></h2><p>There is an extension for <code>TermInterface</code> (and <code>SymbolicUtils</code>) which should allow the symbolic simplification routines from <code>SymbolicUtils</code> to be of use.</p><pre><code class="language-julia hljs">using SymbolicUtils;
@vars x
simplify(sin(x)^2 + cos(x)^2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">sin(x)^2 + cos(x)^2</code></pre><p>The <code>TermInterface</code> package allows general symbolic expression manipulation. This example shows how some of the functionality of <code>subs</code> can be programmed using the package&#39;s interface.</p><pre><code class="language-julia hljs">using TermInterface

function map_matched(x, is_match, f)
    if SymEngine.is_symbol(x)
        return is_match(x) ? f(x) : x
    end

    is_match(x) &amp;&amp; return f(x)
    iscall(x) || return x
    children = map_matched.(arguments(x), is_match, f)
    maketerm(Basic, operation(x), children, nothing)
end

replace_exact(ex, p, q) = map_matched(ex, ==(p), _ -&gt; q)

function replace_head(ex, u, v)
    !iscall(ex) &amp;&amp; return ex
    args′ = (replace_head(a, u, v) for a ∈ arguments(ex))
    op = operation(ex)
    λ = op == u ? v : op
    ex = maketerm(Basic, λ, args′, nothing)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">replace_head (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">@vars x u
replace_exact(sin(x^2)*cos(x^2), x^2, u) # subs(ex, p =&gt; q)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">sin(x^2)*cos(x^2)</code></pre><pre><code class="language-julia hljs">replace_head(tan(sin(tan(x))), tan, cos)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">tan(sin(tan(x)))</code></pre><h2 id="SymEngine.jl-and-symengine"><a class="docs-heading-anchor" href="#SymEngine.jl-and-symengine"><code>SymEngine.jl</code> and symengine</a><a id="SymEngine.jl-and-symengine-1"></a><a class="docs-heading-anchor-permalink" href="#SymEngine.jl-and-symengine" title="Permalink"></a></h2><p>This package only wraps those parts of symengine that are exposed through its <a href="https://github.com/symengine/symengine/blob/master/symengine/cwrapper.cpp">C wrapper</a>. The underlying C++ library has more functionality.</p><h2 id="License"><a class="docs-heading-anchor" href="#License">License</a><a id="License-1"></a><a class="docs-heading-anchor-permalink" href="#License" title="Permalink"></a></h2><p><code>SymEngine.jl</code> is licensed under the MIT open source license.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../apidocs/">« API Documentation</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Wednesday 2 April 2025 18:00">Wednesday 2 April 2025</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
